<html><head><title>Patterns and Ndefs</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider WORKSHOPS (extension)</div>
<div id='categories'><a href='./../Browse.html#Tutorials/ComputerDotPlay'>Tutorials/ComputerDotPlay</a></div>
<h1>Patterns and Ndefs</h1>
<div id='summary'>Computer.play(Music, Creativity &amp; Code)</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../Computer.html">Computer.play</a>, <a href="./../Workshops/Playing with UGens.html">Playing with UGens</a>, <a href="./../Study Guides/Digital Synthesis.html">Digital Synthesis</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#Patterns'>Patterns</a></li>
<ul class='toc'><li class='toc2'><a href='#Pseq'>Pseq</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Pbind'>Pbind</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Math%20with%20Patterns'>Math with Patterns</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Filtering%20streams%20(and%20patterns)'>Filtering streams (and patterns)</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Events%20and%20Patterns'>Events and Patterns</a></li>
<ul class='toc'><li class='toc2'><a href='#Useful%20keys%20for%20notes'>Useful keys for notes</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Music%20with%20Patterns'>Music with Patterns</a></li>
<ul class='toc'><li class='toc2'><a href='#Scales%20and%20Tuning'>Scales and Tuning</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Patterns%20and%20Buffers'>Patterns and Buffers</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Ndefs'>Ndefs</a></li>
<ul class='toc'><li class='toc2'><a href='#Combining%20Ndefs'>Combining Ndefs</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Pdef%20and%20Pdefn%20review'>Pdef and Pdefn review</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Combining%20Ndefs%20and%20Pdefs'>Combining Ndefs and Pdefs</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Effects%20and%20mixing%20with%20Ndefs'>Effects and mixing with Ndefs</a></li>
<ul class='toc'></ul></ul></ul></div><h2><a class='anchor' name='Patterns'>Patterns</a></h2>

<p><strong>Patterns</strong>, like routines, are very useful for scheduling different events in SC. They are good for specifying sequences of different actions that might happen either together or after each other. You can specify many events over time using Patterns. They are convenient for dealing with multiple timings and event repetitions. They are often used to specify musical patterns, whether they are rhythmic patterns or a sequence of pitches.<div class='note'><span class='notelabel'>NOTE:</span> Patterns can be very convenient for Generative Music and Algorithmic Composition!</div>
<p>Patterns use <strong>Streams</strong>: a class that represents a sequence of values that are obtained with the <strong>next</strong> message.
<p>Patterns are an easy way to make multiple streams from a single specification. It is like cloning the patterns or to switch metaphors, using a cookie cutter to produce many similar streams.<div class='note'><span class='notelabel'>NOTE:</span> Streams produce one value each time they receive a <strong>next</strong> message.</div>
<p>Patterns are a way of specifying what a stream should do.
<p>There are many types of Patterns, some of which, we will explore today.<h3><a class='anchor' name='Pseq'>Pseq</a></h3>

<p><code class='code prettyprint lang-sc'>Pseq</code> is a Pattern that produces a sequence of events that can be repeated a specified amount of times.
<p><code class='code prettyprint lang-sc'>Pseq(list, repeats)</code>
<p>loops through a list, repeats a number of times.<pre class='code prettyprint lang-sc'>(
a = Pseq([60,64,67,69], 2).asStream;
8.do({a.next.postln});
)</pre>

<p>Previously we have seen how we can schedule a sequence of events through a <strong>Routine</strong>. This can be simplified using a <code class='code prettyprint lang-sc'>Pattern</code>.<pre class='code prettyprint lang-sc'>//synthdef
(
    SynthDef( "perkysine", {
    | freq=400, amp=1, out=0|
    var osc;
    osc = SinOsc.ar( [freq,freq+0.05.rand] ) * EnvGen.ar(
    Env.perc, doneAction: 2) * 0.2;
    Out.ar(out,osc*amp);
    }).store;
)
//routine
(
    p = {
        2.do{
        Synth(\perkysine, [\freq,60.postln.midicps]);
        0.2.yield;
        Synth(\perkysine, [\freq,60.postln.midicps]);
        0.2.yield;
        Synth(\perkysine, [\freq,67.postln.midicps]);
        0.2.yield;
        Synth(\perkysine, [\freq,69.postln.midicps]);
        0.2.yield;
        }
    }.fork;
)
//pattern
Pbind(\instrument, \perkysine, \midinote, Pseq([60,60,67,69],2), \dur, 0.2, \legato, 1.0).play
//more complex (minimalist) example::
(
~notes1 = [0,2,4,5,7,9,11];
~notes2 = [~notes1[0], ~notes1[2], ~notes1[4]];
~par1 = Pbind(\instrument, \perkysine, \degree, Pseq(~notes1.scramble,inf), \dur, 0.2, \legato, 0.5, \amp, 0.7);
~par2 = Pbind(\degree, Pseq(~notes2,inf), \ctranspose, -12, \dur, 0.3, \legato, 0.8);
~par3 = Pbind(\degree, Pseq((~notes2+0.2).reverse,inf), \ctranspose, -12, \dur, 0.4, \legato, 0.3);
Ppar([~par1, ~par2, ~par3]).play;
)</pre>
<h3><a class='anchor' name='Pbind'>Pbind</a></h3>

<p><code class='code prettyprint lang-sc'>Pbind</code> is a pattern "player". It takes a variety of patterns and matches them to Events. These events produce sounds and modify different arguments and behaviour.
<p><code class='code prettyprint lang-sc'>Pbind</code> is a class that lets you match properties of a sound event with values<ul>
<li>e.g. freq or midinote to create frequencies<li>dur for duration<li>amp for amplitude<li>instrument for instrument</ul>

<p>You can find more information on the types of useful Events available <a href="./../Workshops/Patterns, Effects and Ndefs.html#Events%20and%20Patterns">below</a>.
<p>To play default values of <code class='code prettyprint lang-sc'>Pbind</code>:<pre class='code prettyprint lang-sc'>a = Pbind.new.play   // if no additional arguments, new method must explicitly be used
a.stop</pre>

<p>to change duration:<pre class='code prettyprint lang-sc'>Pbind(\dur,0.125).play</pre>

<p>to play a chord:<pre class='code prettyprint lang-sc'>Pbind(\midinote,[60,64,67,69]).play</pre>

<p>to play with a different instrument:
<p><code class='code prettyprint lang-sc'>SynthDef</code> needs to receive the store message which stores and loads the synthdef but also adds it to the <code class='code prettyprint lang-sc'>SynthDescLib</code> so it can be used with <code class='code prettyprint lang-sc'>Pbind</code>.<pre class='code prettyprint lang-sc'>    SynthDescLib.global.read   // prepares a library of SynthDesc objects
    SynthDescLib.global.browse</pre>

<p>your instrument should use <code class='code prettyprint lang-sc'>doneAction: 2</code> to release the <code class='code prettyprint lang-sc'>Synth</code>.<pre class='code prettyprint lang-sc'>(
SynthDef(\strum,{
 |freq = 440, out=0|
 var trigger, pluck, period, string, output;
     trigger = HPZ1.kr(XLine.kr(1,0,0.01)).abs;
     pluck = PinkNoise.ar(Decay.kr(trigger, 0.05));
     period = freq.reciprocal;
     string = CombL.ar(pluck,period, period, 4);
    output = LPF.ar(string,12000);
    output = LeakDC.ar(output);
    DetectSilence.ar(output, doneAction: 2);
    Out.ar(out,output)
}).store
)

Synth(\strum)

Pbind(\instrument,\strum).play

(
Pbind(\instrument,\strum,
    \midinote,[60,64,67,69]
 ).play
)
//this is SC's default synth
Synth(\default, [\freq, 400]);
//if you don't specify an instrument, Pbind will play default synth
Pbind(\midinote, [60,64,67,69]).play;</pre>

<p>To play notes in series, you need to use a <code class='code prettyprint lang-sc'>Pattern</code>
<p>Individual types of patterns will be explained later. For now, they will just be used.
<p><code class='code prettyprint lang-sc'>Pseq</code> iterates over a list of objects:
<p>(list, repeats, offset)
<p>note the additional binding for <code class='code prettyprint lang-sc'>dur</code>:<pre class='code prettyprint lang-sc'>(
Pbind(\instrument,\strum,
    \dur, 0.5,
    \midinote,Pseq([60,64,67,69],2)
).play
)</pre>

<p>A <code class='code prettyprint lang-sc'>Pattern</code> returns a <code class='code prettyprint lang-sc'>nil</code> after the repetitions are complete.<pre class='code prettyprint lang-sc'>a = Pseq([1, 3, 400]);
x = a.asStream;
x.next; //evaluate this line several times</pre>

<p><code class='code prettyprint lang-sc'>Pbind</code> will stop playing when a <code class='code prettyprint lang-sc'>Pattern</code> returns a <code class='code prettyprint lang-sc'>nil</code>.<pre class='code prettyprint lang-sc'>(
Pbind(\instrument,\strum,
    \dur, 0.5,
    \midinote,Pseq([60,64,67,69])
).play
)</pre>

<p>To infinitely repeat a <code class='code prettyprint lang-sc'>Pattern</code>, use <code class='code prettyprint lang-sc'>inf</code> for the number of repeats<pre class='code prettyprint lang-sc'>(
Pbind(\instrument,\strum,
    \dur, 0.5,
    \midinote,Pseq([60,64,67,69],inf)
).play
)</pre>

<p>Offset gives a starting offset (index) into the list<pre class='code prettyprint lang-sc'>(
Pbind(\instrument,\strum,
    \dur, 0.5,
    \midinote,Pseq([60,64,67,69],2,3) //list, repeats, offset
).play
)</pre>

<p><code class='code prettyprint lang-sc'>Pser</code>
<p>repeats variable gives the number of values returned rather than the number of cycles<pre class='code prettyprint lang-sc'>(
Pbind(\instrument,\strum,
    \dur, 0.5,
    \midinote,Pser([60,64,67,69],5)
).play
)</pre>

<p><code class='code prettyprint lang-sc'>Prand</code>
<p>returns one item at random
<p>repeats is the number of items returned before returning a <code class='code prettyprint lang-sc'>nil</code><pre class='code prettyprint lang-sc'>(
var num = 20;
Pbind(\instrument,\strum,
    \dur,Prand([ 0.15,0.25,0.35,0.5],num),
    \midinote,Prand((60..72),num)
).play
)</pre>

<p>use frequencies instead of midinotes<pre class='code prettyprint lang-sc'>(
var num = 50;
Pbind(\instrument,\strum,
    \dur,Prand([ 0.15,0.25,0.35,0.5] * 0.5,num),
    \freq,Prand((200,210..600),num)
).play
)</pre>

<p><code class='code prettyprint lang-sc'>Pxrand</code>
<p>returns one item at random but does not repeat twice in a row<pre class='code prettyprint lang-sc'>(
var num = 50;
Pbind(\instrument,\strum,
    \dur,Pxrand([ 0.15,0.25,0.35,0.5],num),
    \freq,Pxrand((510,520..600),num)
).play
)</pre>

<p><code class='code prettyprint lang-sc'>Pshuf</code>
<p>loops through a list that has been scrambled
<p>the list is repeated without reshuffling<pre class='code prettyprint lang-sc'>(
Pbind(\instrument,\strum,
    \dur,0.3,
    \midinote,Pshuf((60..65),5)
).play
)</pre>

<p><code class='code prettyprint lang-sc'>Prand(list, repeats)</code>
<p>Repeats for this pattern refers to the number of values returned, not the number of cycles.<pre class='code prettyprint lang-sc'>(
a = Prand([60,64,67,69],10).asStream;
12.do({a.next.postln})
)

(
p = Prand((48 ..72), inf); // pattern repeats forever: inf
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play
)</pre>

<p><code class='code prettyprint lang-sc'>Pwrand(lists, weights, repeats)</code>
<p>Weighted random choice
<p>weights is a list of probabilities (0-1)<pre class='code prettyprint lang-sc'>(
a = Pwrand([1,2,3,4],[0.5,0.1,0.2,0.2],20).asStream;
20.do({a.next.postln})
)</pre>

<p>It seems (empirical observation) that the probabilities do not need to add up to 1, however once the probabilities add up to one, any event with a probability above this threshold seems to be ignored. In the following example, 4 never seems to occur.<pre class='code prettyprint lang-sc'>(
a = Pwrand([1,2,3,4],[0.5,0.1,0.5,0.2],20).asStream;
20.do({a.next.postln})
)</pre>

<p>Weighted frequencies:<pre class='code prettyprint lang-sc'>(
p = Pwrand((60 ..72),[4,3,1,1,0.5,2,1,1,1,1.5,3,1].normalizeSum.postln, inf).asStream;
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play;
)</pre>

<p><code class='code prettyprint lang-sc'>normalizeSum</code> normalizes the values so the sum of the <code class='code prettyprint lang-sc'>Array</code> is 1.
<p><code class='code prettyprint lang-sc'>Pxrand(lists, repeats)</code>
<p>returns 1 item at random but does not repeat twice in a row.<pre class='code prettyprint lang-sc'>(
a = Pxrand([60,61,62],10).asStream;
a.nextN(10)
)</pre>

<p>The <code class='code prettyprint lang-sc'>nextN</code> message when sent to a stream will collect n values in an <code class='code prettyprint lang-sc'>Array</code>.<pre class='code prettyprint lang-sc'>(
p  = Pxrand([60,61,62],20);
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play;
)</pre>

<p><code class='code prettyprint lang-sc'>Pstutter(n, pattern)</code>
<p>repeats each element n times<pre class='code prettyprint lang-sc'>(
a = Pstutter(2, Pseq([1,2,3],inf)).asStream;
a.nextN(10);
)</pre>

<p>n may also be a pattern so that it can vary each iteration.<pre class='code prettyprint lang-sc'>(
p = Prand((48 ..72), inf);
d = Pstutter(Prand((1..5),inf), Prand([0.1,0.15,0.2,0.3], inf)); //amount of repetitions varies each iteration
Pbind(\instrument, \perkysine, \midinote, p, \dur, d, \amp, 0.1).play;
)</pre>

<p><code class='code prettyprint lang-sc'>Pseries(start, step-size, length)</code>
<p>generates an arithmetic series<pre class='code prettyprint lang-sc'>(
p = Pseries(48,2,13).asStream;
p.nextN(13)
)</pre>

<p>Applied to frequency:<pre class='code prettyprint lang-sc'>(
p = Pseries(48,2,13).asStream;
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.1, \amp, 0.1).play;
)</pre>

<p><code class='code prettyprint lang-sc'>Pgeom(start, multiplication-factor, length)</code>
<p>generates a geometric series<pre class='code prettyprint lang-sc'>(
p = Pgeom(1,0.8,20).asStream;
p.nextN(20);
)</pre>

<p>applied to duration:<pre class='code prettyprint lang-sc'>(
p =  Pgeom(1,0.8,20).asStream;
Pbind(\instrument, \perkysine, \freq, 440, \dur, p, \amp, 0.1).play;
)</pre>
<h3><a class='anchor' name='Math%20with%20Patterns'>Math with Patterns</a></h3>

<p>Either unary or binary operators can be used with Patterns (or streams)
<p><code class='code prettyprint lang-sc'>Pattern</code> followed by 2 transpositions in one sequence<pre class='code prettyprint lang-sc'>(
p  = Pseq([60,64,64,65,68,69,71]);
q = Pseq([p,p+7,p+5],inf).asStream;
Pbind(\instrument, \strum, \midinote, q, \dur, 0.1, \amp, 0.1).play;
)</pre>

<p>Add two patterns
<p>This will transpose each fifth note down two octaves.<pre class='code prettyprint lang-sc'>(
p = Prand((60 ..72), inf) + Pseq([0,0,0,0,-24], inf);
Pbind(\instrument, \perkysine, \midinote, p, \dur, 0.2, \amp, 0.1).play;
)</pre>
<h3><a class='anchor' name='Filtering%20streams%20(and%20patterns)'>Filtering streams (and patterns)</a></h3>

<p>Patterns can be filtered with <code class='code prettyprint lang-sc'>Padd, Pmul, Pset,</code> and <code class='code prettyprint lang-sc'>Pstretch</code>.
<p>Streams can also be filtered.
<p>Streams respond to the messages: <code class='code prettyprint lang-sc'>collect, select, reject</code>
<p>by returning a new stream
<p>collect
<p>collect returns a stream that is modified by some function<pre class='code prettyprint lang-sc'>(
p = Prand((60 ..72), inf).asStream;
q = p.collect({|item| if (item.even,{item - 24}, {item})});
q.nextN(10);
)</pre>

<p>This example returns a stream that transposes even note numbers down two octaves:<pre class='code prettyprint lang-sc'>(
p = Prand((60 ..72), inf).asStream;
q = p.collect({|item| if (item.even,{item - 24}, {item})});
Pbind(\instrument, \perkysine, \midinote, q, \dur, 0.2, \amp, 0.1).play;
)</pre>

<p>select
<p>creates a stream that passes only items that return true from a supplied function<pre class='code prettyprint lang-sc'>(
p = Prand((48 ..72), inf).asStream;
q = p.select({|item| item.even});
q.nextN(10);
)</pre>

<p>selects only the even Midi note numbers:<pre class='code prettyprint lang-sc'>(
p = Prand((60 ..72), inf).asStream;
q = p.select({|item| item.even});
Pbind(\instrument, \perkysine, \midinote, q, \dur, 0.2, \amp, 0.1).play;
)</pre>

<p>reject
<p>is similar to select except that it passes only items that return false from a supplied function
<p>reject the even numbers<pre class='code prettyprint lang-sc'>(
p = Prand((48 ..72), inf).asStream;
q = p.reject({|item| item.even});
q.nextN(10);
)
rejects only the event Midi note numbers
code::
(
p = Prand((60 ..72), inf).asStream;
q = p.select({|item| item.even});
Pbind(\instrument, \perkysine, \midinote, q, \dur, 0.2, \amp, 0.1).play;
)</pre>

<p><strong>Exercise</strong>:
<p>Try understanding the use of patterns in the examples below and start modifying them to achieve other results.<pre class='code prettyprint lang-sc'>Pbind(\freq,Pseq([440,660]), \instrument,\perkysine).play

(
// changing duration
Pbind(
    \dur, Pseq([ Pgeom(0.05, 1.1, 24),
                Pgeom(0.5, 0.909, 24) ], inf),
    \midinote, Pseq([60, 58], inf)
).play
)

(
Pbind( \instrument,\perkysine,\dur, 0.1,
    \midinote,  Pwrand(
    [Pseq([60,64,67,69]),
     Pseq([Prand((80..90)),50,51])
    ], [0.7,0.3],inf),
\amp, 0.1).play
)</pre>

<p>Patterns can be built of arbitrary complexity by nesting<pre class='code prettyprint lang-sc'>Pseq([Pseq([100, 200, 300], 2), 400, 500, 600], inf);</pre>

<p>Examples of nested Patterns<pre class='code prettyprint lang-sc'>(
Pbind(
    \freq, Pseq([Pseq([100, 200, 300], 2), 400, 500, 600],inf)
).play;
)

(
Pbind(
    \freq, Pseq([Prand([440, 442, 445, 448]), Pxrand([840, 741, 642], 2)], inf)
// Pxrand never repeats the same value from the array twice in a row
).play;
)</pre>
<h2><a class='anchor' name='Events%20and%20Patterns'>Events and Patterns</a></h2>

<p>It's important to understand that <code class='code prettyprint lang-sc'>Pbind</code> is doing some things for you behind the scenes.
<p>Patterns use Events, which affect the behaviour and sound quality of the output. Here is an example:<pre class='code prettyprint lang-sc'>(
Pbind(
    \freq, Pseq([440, 660, 990, 880, 770], inf),     // frequency in hertz
    \dur, Pseq([1.0, 0.5],inf),                          // duration of event in beats
    \legato, 0.5,                                          // proportion of inter onset time to play
    \pan, Pseq([0.5, -0.5],inf),
    \instrument, \default
).play;
)</pre>

<p>You can see the default properties (or keys) of Events by looking at the defaults defined in the class.<pre class='code prettyprint lang-sc'>[Meta_Event:makeParentEvents] //cmd + i</pre>
<h3><a class='anchor' name='Useful%20keys%20for%20notes'>Useful keys for notes</a></h3>

<p>Using Events is largely a matter of overwriting keys. Here is a list of keys useful for defining notes with their default values, grouped by the partialEvent within which they are defined.<ul>
<li><strong>serverEvent keys</strong>:</ul>

<p>The keys in serverEvent provide the values needed to identify the server to be used and where in the tree of nodes to place the group.<pre class='code prettyprint lang-sc'>server:        nil,        // if nil, Server.default is used
instrument:    \default,    // this is the name of a SynthDef
group:        1,        // nodeID of group on the server
                // when adding before or after a node
                // this could be the nodeID of a synth instead of a group
addAction:    0,        // 0, 1, 2, 3 or \addToHead, \addToTail, \addBefore, \addAfter
out:        0,        // usually an output bus number, but depends on the SynthDef</pre>

<p><ul>
<li><strong>ampEvent keys</strong>:</ul>

<p>The ampEvent determines volume. Notice that <code class='code prettyprint lang-sc'>~amp</code> is a function that determines its value from <code class='code prettyprint lang-sc'>~db</code>. The user can choose to specify the amplitude directly by overwriting <code class='code prettyprint lang-sc'>~amp</code> or to use a decibel specification by overwriting <code class='code prettyprint lang-sc'>~db</code>.<pre class='code prettyprint lang-sc'>amp:        #{ ~db.dbamp },    // the amplitude
db:        -20.0,        // the above described in decibel
pan:        0.0,        // pan position: -1 left 1 right
velocity:    64        // midi velocity
trig:        0.5        // trigger value</pre>
<ul>
<li><strong>durEvent keys</strong>:</ul>

<p>The durEvent has keys that determine the timing of a note. Notice that <code class='code prettyprint lang-sc'>~sustain</code> is a function that uses <code class='code prettyprint lang-sc'>~legato</code> to determine the sustain. Like <code class='code prettyprint lang-sc'>~amp</code> this can be overwritten to set the sustain directly.<pre class='code prettyprint lang-sc'>tempo:            nil,    // changes tempo of a TempoClock
dur:            1.0,    // time until next note (inter-onset time)
stretch:        1.0,    // inverse of tempo control, specific to the Event's stream
legato:            0.8,    // ratio of sustain to duration
sustain:        #{ ~dur * ~legato * ~stretch },
lag:            0.0,    // delay (in seconds) relative to current time position of Stream
timingOffset:        0.0,    // delay (in beats) relative to current time position of Stream
strum:            0.0    // "breaks" a chord. May be negative, playing the chord backward
strumEndsTogether:    false    // if true, the strummed notes end together (with gated synths)
sendGate:        nil  // override: true == always send a gate-release message; false == never send</pre>
<ul>
<li><strong>pitchEvent keys</strong>:</ul>

<p>The pitchEvent has the most complex system of functions that provide a variety of useful ways to determine pitch:<pre class='code prettyprint lang-sc'>freq (-&gt;440)        // determines the pitch directly as a frequency in Hertz
midinote (-&gt; 60)    // determines pitch as a fractional MIDI note (69 -&gt; 440)
note (-&gt; 0)        // determines pitch as a scale degree in an ~stepsPerOctave equal tempered scale
degree: 0        // determines pitch as a scale degree within the scale ~scale</pre>

<p>The event also provides a set of transposition keys:<pre class='code prettyprint lang-sc'>mtranspose:    0    // modal transposition of degree within a scale
root:        0.0    // transposes root of the scale
gtranspose:    0.0    // gamut transposition within the ~stepsPerOctave equal tempered scale
ctranspose:    0.0    // chromatic transposition within the 12 tone equal tempered scale
harmonic:    1.0    // multiplies the frequency determined by ~midinote, typically to an overtone
detune:        0.0    // directly offsets frequency by adding this value
midiToCps        // a function taking a MIDI note number and turning it into frequency
            // Normally this is _.midicps, but you can override it for non-ET tunings

mtranspose:    0,    // modal transposition of degree
gtranspose:    0.0    // gamut transposition of note within a ~stepsPerOctave e.t. scale
ctranspose:    0.0    // chromatic transposition of midinote within 12 tone e.t. scale

octave:        5.0    // octave offset of note
root:        0.0    // root of the scale
degree:        0    // degree in scale
scale:        #[0, 2, 4, 5, 7, 9, 11]    // diatonic major scale
stepsPerOctave:    12.0    //
detune:        0.0,    // detune in Hertz
harmonic:    1.0    // harmonic ratio
octaveRatio:    2.0    // size of the octave (can be used with the Scale class)</pre>
<h2><a class='anchor' name='Music%20with%20Patterns'>Music with Patterns</a></h2>

<p>Now we can do more musical and complex things with Patterns, like playing several of them at the same time.
<p><code class='code prettyprint lang-sc'>Ppar(list, repeats)</code>
<p>Play several Patterns at the same time in parallel:<pre class='code prettyprint lang-sc'>(
var melodypat, basspat;

melodypat = Pbind(
        [\midinote, \dur],
        Prand([
            [60, 0.75],[64, 0.5],[66, 0.5],[69, 0.25],
            [67,0.75],[64,0.5],[60,0.5],[57,0.25]
        ],inf)
);

basspat = Pbind(
        \midinote, Pseq([48, 42], inf),
        \dur, 1
);

Ppar([ melodypat, basspat ]).play);
)</pre>

<p>Now, let's add a conductor to our patterns.
<p><code class='code prettyprint lang-sc'>PatternConductor(patterns, event, quant)</code><pre class='code prettyprint lang-sc'>(
var melodypat, basspat;

melodypat = Pbind(
        [\midinote, \dur],
        Prand([
            [60, 0.75],[64, 0.5],[66, 0.5],[69, 0.25],
            [67,0.75],[64,0.5],[60,0.5],[57,0.25]
        ],inf)
);

basspat = Pbind(
        \midinote, Pseq([48, 42], inf),
        \dur, 1
);

p = Ppar([ melodypat, basspat ]);
a = PatternConductor(p);
a.play;
)

a.tempo = 2;
a.tempo = 0.5;

a.pause;
a.resume;
a.stop;
a.play;
a.stop;</pre>

<p>You can use <code class='code prettyprint lang-sc'>Pset</code>, to set a different parameter of another pattern.<pre class='code prettyprint lang-sc'>Pset(name, value, pattern)

(
~notepat = Pseq([60,64,66,69,67,64,60,57], inf);
~melodypat = Pbind(\midinote, ~notepat);
~modpat = Pset(\midinote, ~notepatt-24, ~melodypat);
Pset(\amp, 1, ~modpat).play;
)</pre>

<p>You can modify a <code class='code prettyprint lang-sc'>Pbind</code> with a <code class='code prettyprint lang-sc'>Pbindf</code>.<pre class='code prettyprint lang-sc'>Pbindf(pattern, pairs)

(
~melodypat = Pbind(\midinote, Pseq([60,64,66,69,67,64,60,57], inf));

Pbindf(~melodypat, \dur, Pseq([0.75,0.5,0.5,0.25,0.75,0.5,0.5,0.25].scramble, inf)*0.3, \instrument, \perkysine).play;
)</pre>

<p>Now, let's start to do some pattern live coding (changing patterns on the fly). This is a lot of fun and can be useful for your projects! For this, we need a class called <code class='code prettyprint lang-sc'>Pdef</code>
<p><code class='code prettyprint lang-sc'>Pdef(key, pat)</code>
<p>Creates a pattern definition that you can change. When you change the content of Pdef, the pattern definition propagates through all streams.<pre class='code prettyprint lang-sc'>(
~melodypat = Pbind(
        [\midinote, \dur],
        Prand([
            [60, 0.75],[64, 0.5],[66, 0.5],[69, 0.25],
            [67,0.75],[64,0.5],[60,0.5],[57,0.25]
        ],inf)
);

~basspat = Pbind(
        \midinote, Pseq([48, 42], inf),
        \dur, 1
);

p = Ppar([ ~melodypat, ~basspat ]);
a = PatternConductor(Pdef(\mypattern, p));
a.play;
)
(
~transp = rrand(0,11).postln;
~basspat2 = Pbindf(~basspat, \ctranspose, ~transp, \legato, 0.8);
~melodypat2 = Pbindf(~melodypat, \ctranspose, ~transp, \legato, 0.3);
Pdef(\mypattern, Ppar([ ~melodypat2, ~basspat2],inf)).quant(4); //quantize
)
a.stop;</pre>
<h3><a class='anchor' name='Scales%20and%20Tuning'>Scales and Tuning</a></h3>

<p>Another example, a variation on the minimalist one above. This example uses the <code class='code prettyprint lang-sc'>Scale</code> and <code class='code prettyprint lang-sc'>Tuning</code> classes. These classes can save you some time counting intervals and figuring tuning ratios. Basically, SC makes the calculations for you! Each class has many different types of Scales and Tuning systems. Check the helpfile of both classes!
<p>If you want to know which Scales and Tuning are available, evaluate the code below:<pre class='code prettyprint lang-sc'>Scale.directory;
Tuning.directory;</pre>

<p>Now, let's combine the <code class='code prettyprint lang-sc'>Scale</code> and <code class='code prettyprint lang-sc'>Tuning</code> classes with patterns!<pre class='code prettyprint lang-sc'>Pdef(\minimal).play;
Pdef(\minimal).quant(4);
(
~tuning = Tuning.just;
~scale = (0..7);
~triad = [~scale[0], ~scale[2], ~scale[4]];
~par1 = Pbind(\instrument, \perkysine, \scale, Scale.major(~tuning), \degree, Pseq(~scale.scramble,inf), \dur, 0.2, \legato, 0.5, \amp, 0.7);
~par2 = Pbind(\degree, Pseq(~triad,inf), \ctranspose, -12, \dur, 0.3, \legato, 0.8);
~par3 = Pbind(\degree, Pseq((~triad+0.2).reverse,inf), \ctranspose, -12, \dur, 0.4, \legato, 0.3);
Pdef(\minimal, Ppar([~par1, ~par2, ~par3]));
)
//once you start evaluating, then start changing values, scale and tuning types,etc.</pre>
<h3><a class='anchor' name='Patterns%20and%20Buffers'>Patterns and Buffers</a></h3>

<p>You can also use patterns with buffers! For this, you need to make your own SynthDefs and allocate the buffers you want to use:<pre class='code prettyprint lang-sc'>//load soundfiles
a = Buffer.loadDialog;
b = Buffer.loadDialog;

(
SynthDef("playGrain", {arg bufnum=0, time=0.1, rate=1, start=0, out=0;
    var sig;
    sig = PlayBuf.ar(2, bufnum, rate, startPos: BufFrames.kr(bufnum)*start)
    * EnvGen.ar(Env.linen(0.01,time,0.1), doneAction:2);
    Out.ar(out,sig);
}).add;
)

Synth("playGrain", [\bufnum, a.bufnum, \start, 0.9]);

~bufSeq = Pseq([a,a,a,b,b,b], inf);

~drumPat1 = Pseq([0,\rest,\rest,0,\rest], inf);
~pat1 = Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat1, \dur, 0.5, \time, 0.2)

Pdef(\pattern, ~pat1);

~conduct = PatternConductor(Pdef(\pattern));
~conduct.play;

Pdef(\pattern).quant = 6;

~drumPat1 = Pseq([0,0,\rest,0,\rest,\rest], inf);
~pat1 = Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat1, \dur, 0.4, \time, 0.1, \start, Pseq([0,0.1,0.3,0.5,0.6,0.7],inf));

Pdef(\pattern, ~pat1);

~drumPat2 = Pseq([\rest,0,\rest,\rest,0,0], inf);
~pat2 = Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat2, \dur, 0.4, \time, 0.01, \start, Pseq([0,0,0,0.7],inf), \rate, Prand([1,2,3],inf));

Pdef(\pattern, Ppar([~pat1, ~pat2], inf));

~drumPat3 =Pshuf([0,0,\rest,0,1,0], inf);
~pat3 = Pbind(\instrument, \playGrain, \bufnum, ~bufSeq, \degree, ~drumPat3, \dur, 0.4, \time, 0.1, \start, Prand([0.15,0.6],inf, \rate, Pseq([20,0.3,0.8,0.4],inf)));

Pdef(\pattern, Ppar([~pat1, ~pat2, ~pat3], inf));

~conduct.tempo = 1.7; //change tempo

Scale.directory;
Tuning.directory;

~tuning = Tuning.pythagorean;
~scale = Scale.phrygian(~tuning);
~notes = (0..5);

~pat4 = Pbind(\scale, ~scale, \degree, Prand(~notes,inf), \ctranspose, -12, \amp, 2, \dur, Prand([2/3,1/3],inf), \legato, 0.05);

Pdef(\pattern, Ppar([~pat1, ~pat2, ~pat3, ~pat4], inf));

Pdef(\pattern, Ppar([~pat2,~pat4], inf));

~conduct.stop;</pre>
<h2><a class='anchor' name='Ndefs'>Ndefs</a></h2>

<p>We just were introduced to <code class='code prettyprint lang-sc'>Pdef</code>: a pattern <strong>definition</strong>. Previously we've also talked about <code class='code prettyprint lang-sc'>SynthDef</code>: a synthesis definition. In SC, there are many types of <strong>definitions</strong>. A definition is a class that is characterised by having a key: a way of naming an instance of a class with a <code class='code prettyprint lang-sc'>Symbol</code>. Symbols are like strings, but they are not a collection of letters, but a single word expressed like this: <code class='code prettyprint lang-sc'>\symbol</code>. Instead of having to use many variables to define an instance of a class, you can define it with a key. Then SC remembers that instance and you can start changing it. In the case of <code class='code prettyprint lang-sc'>Pdef</code>, we used the key to define a pattern behaviour that then we can access and change.
<p>Ndefs, are <code class='code prettyprint lang-sc'>NodeProxy</code> definitions. In electronic and computer music, we deal a lot with signals and the different 'routes' they might take and how we might combine them. If you are familiar with the recording process, you know that the signal path is important for what you want to achieve. If you have used a mixer, whether it is an analogue mixer or a mixer in your DAW, you are probabily familiar with the idea of Buses and Groups. You can route different channels through Buses. You can join various channels together with Groups.
<p>In SC, we have the Server, which plays the audio. We keep reference of what is playing in the server through what is called a Node. SC keeps what's called a Node tree in the server to keep reference of everything that's playing in it. You can look at the Node tree from the server's drop down menu if you click on the server information in the left corner. SC also has a <code class='code prettyprint lang-sc'>Bus</code> class and a <code class='code prettyprint lang-sc'>Group</code> class for doing more complex routing. But we have to do a lot of bookkeeping of which buses and groups we are using. Ndefs do that bookkeeping for us! And believe me, when things get a bit more complicated, that is a great thing! So an <code class='code prettyprint lang-sc'>Ndef</code> helps us with signal routing in a very intuitive way, and what's best, you can do this routing on the fly! Cool ha!
<p>Ok, here's how Ndefs work:
<p>First, we define and play a Node definition<pre class='code prettyprint lang-sc'>Ndef(\sound).play;</pre>

<p>Then we can determine the definition's fade time<pre class='code prettyprint lang-sc'>Ndef(\sound).fadeTime = 1;</pre>

<p>Now, let's put a synth in the Node definition:<pre class='code prettyprint lang-sc'>Ndef(\sound, { SinOsc.ar([600, 635], 0, SinOsc.kr(2).max(0) * 0.2) });</pre>

<p>Ok, now let's put a different synth in the Node definition:<pre class='code prettyprint lang-sc'>Ndef(\sound, { SinOsc.ar([600, 635] * 3, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });</pre>

<p>Did you notice fade? Cool right!<pre class='code prettyprint lang-sc'>Ndef(\sound, { SinOsc.ar([600, 635] * 2, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });</pre>

<p>In addition to Synths, you can play patterns!<pre class='code prettyprint lang-sc'>Ndef(\sound, Pbind(\dur, 0.17, \freq, Pfunc({ rrand(300, 700) })) );</pre>

<p>Ok, let's start combining signals:
<p>Let's start with a very basic, "defaulty" synth:<pre class='code prettyprint lang-sc'>Ndef(\sound, \default );</pre>

<p>Now, we're going to create a new <code class='code prettyprint lang-sc'>Ndef</code> to control the other <code class='code prettyprint lang-sc'>Ndef</code><pre class='code prettyprint lang-sc'>Ndef(\lfo, { LFNoise1.kr(3, 400, 800) });</pre>

<p>Let's map the frequency argument with the <code class='code prettyprint lang-sc'>Ndef</code> we just created:<pre class='code prettyprint lang-sc'>Ndef(\sound).map(\freq, Ndef(\lfo));</pre>

<p>Change the original synth:<pre class='code prettyprint lang-sc'>Ndef(\sound, { arg freq; SinOsc.ar([600, 635] + freq, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });</pre>

<p>Change the modulating signal:<pre class='code prettyprint lang-sc'>Ndef(\lfo, { LFNoise1.kr(300, 400, 800) });</pre>

<p>Now, let's stop mapping values the frequency argument with the Ndef we just created<pre class='code prettyprint lang-sc'>Ndef(\sound).unmap(\freq);</pre>

<p>Let's stop it now:<pre class='code prettyprint lang-sc'>Ndef.clear; //clear all</pre>

<p>That was cool, wasn't it! You were patching and changing your synthesis patch on the fly!<h3><a class='anchor' name='Combining%20Ndefs'>Combining Ndefs</a></h3>

<p>Ndefs can be combined together. This allows you to do very interesting <strong>signal routing</strong>: you can use both <strong>audio</strong> (<code class='code prettyprint lang-sc'>.ar</code>) and <strong>control</strong> (<code class='code prettyprint lang-sc'>.kr</code>) signals and route them through Ndefs.
<p><strong>Control Signals with Ndefs</strong>
<p>Let's start with an example routing control signals.<div class='note'><span class='notelabel'>NOTE:</span> We always use the <code class='code prettyprint lang-sc'>.play</code> message in the last <code class='code prettyprint lang-sc'>Ndef</code> in the signal chain!! In other words, we use this message in the main <code class='code prettyprint lang-sc'>Ndef</code> where we place the other Ndefs (with the other signals we're combining).</div>
<p><pre class='code prettyprint lang-sc'>Ndef(\master).play; //this will be our "master fader" or our "main" Ndef</pre>

<p>Now, let's create two new Ndefs with a control signal (this time, we're using <code class='code prettyprint lang-sc'>MouseX</code> and <code class='code prettyprint lang-sc'>MouseY</code>, to modulate other Ndefs):<pre class='code prettyprint lang-sc'>Ndef(\mouse, {MouseX.kr(0,1)});
Ndef(\mouse2, {MouseY.kr(0,1)});</pre>

<p>Let's now create another <code class='code prettyprint lang-sc'>Ndef</code> called <code class='code prettyprint lang-sc'>\sine</code> and change the amplitude of <code class='code prettyprint lang-sc'>SinOsc</code> with <code class='code prettyprint lang-sc'>Ndef(\mouse)</code>.<div class='note'><span class='notelabel'>NOTE:</span> Notiece that to combine signals with Ndefs, now we need to write the <code class='code prettyprint lang-sc'>.kr</code> message after the <code class='code prettyprint lang-sc'>Ndef</code>!</div>
<p><pre class='code prettyprint lang-sc'>Ndef(\sine, {SinOsc.ar(500)*Ndef.kr(\mouse) });</pre>

<p>Now let's add <code class='code prettyprint lang-sc'>Ndef(\sine)</code> to our <code class='code prettyprint lang-sc'>Ndef(\master)</code>, now we can hear the sound.<pre class='code prettyprint lang-sc'>Ndef(\master, {Ndef(\sine)});</pre>

<p>Now, we change the content of <code class='code prettyprint lang-sc'>Ndef(\sine)</code> with another <code class='code prettyprint lang-sc'>SinOsc</code>. This time, we are adding <code class='code prettyprint lang-sc'>Ndef(\mouse2)</code> to modulate the frequency of the oscillator.<pre class='code prettyprint lang-sc'>Ndef(\sine, {SinOsc.ar(Ndef.kr(\mouse2).linlin(0,1,500,600))*Ndef.kr(\mouse) });</pre>

<p><div class='note'><span class='notelabel'>NOTE:</span> Notice the use of <code class='code prettyprint lang-sc'>.linlin</code> to scale the <code class='code prettyprint lang-sc'>MouseY</code> values in a linear scale from 0 to 1, to 500 to 600, to modulate frequency.</div>
<p><div class='note'><span class='notelabel'>NOTE:</span> Notice the use of the <code class='code prettyprint lang-sc'>.kr</code> message after the <code class='code prettyprint lang-sc'>\mouse2</code> and <code class='code prettyprint lang-sc'>\mouse</code> Ndefs. We have to do this to be able to comine a control <code class='code prettyprint lang-sc'>Ndef</code> within another <code class='code prettyprint lang-sc'>Ndef</code>.</div>
<p>Now, let's add an envelope to our <code class='code prettyprint lang-sc'>Ndef(\sine)</code> synth.<pre class='code prettyprint lang-sc'>Ndef(\sine, {SinOsc.ar(Ndef.kr(\mouse2).linlin(0,1,500,600))*EnvGen.kr(Env.perc(0.01,0.1), doneAction:2) });</pre>

<p>We can use the <code class='code prettyprint lang-sc'>.spawn</code> message to retrigger the synth, as many times as you want!<pre class='code prettyprint lang-sc'>Ndef(\sine).spawn; //evaluate this several times!</pre>

<p>Now, we are going to use another class definition called <code class='code prettyprint lang-sc'>Tdef</code>:
<p>Tdefs are task definitions - a <code class='code prettyprint lang-sc'>Task</code> is a pauseable <code class='code prettyprint lang-sc'>Routine</code> - Tdefs can de defined and changed with a key.<pre class='code prettyprint lang-sc'>Tdef(\imp, {inf.do{
    Ndef(\sine).spawn;
    0.2.yield;
}});

Tdef(\imp).play</pre>

<p>Now we can change the <code class='code prettyprint lang-sc'>Task</code> on the fly!<pre class='code prettyprint lang-sc'>Tdef(\imp, {inf.do{
    Ndef(\sine).spawn;
    [0.1, 0.3].choose.yield;
}});

Tdef(\imp).stop</pre>

<p>Let's combine various Tdefs!!<pre class='code prettyprint lang-sc'>Tdef(\dust, {20.do{
    Ndef(\sine).spawn;
    rrand(0.1, 0.3).yield;
}});

Tdef(\imp, {20.do{
    Ndef(\sine).spawn;
    0.3.yield;
}});

Tdef(\combine, {inf.do{
    Tdef(\dust).embed;
    Tdef(\imp).embed;
}});

Tdef(\combine).play;

Tdef.all;
Tdef.clear;
Ndef.clear;</pre>

<p><strong>Audio Signals with Ndefs</strong>
<p>Now, let's combine different audio signals through Ndefs.
<p>First, start <code class='code prettyprint lang-sc'>Ndef(\master)</code> - we're using this Ndef as out last node in the chain:<pre class='code prettyprint lang-sc'>Ndef(\master).play;</pre>

<p>Create a synth and add it to <code class='code prettyprint lang-sc'>Ndef(\fnoise)</code><pre class='code prettyprint lang-sc'>(
Ndef(\fnoise, {|freq = 440 amp = 0.1 cutoff= 100 rq=0.1 pan=0.0|
    var source, filter, env;
    source = WhiteNoise.ar;
    filter = BLowPass4.ar(source,freq,rq)*0.2;
    (filter*0.4)+(0.3*filter.distort);
});
)</pre>

<p>Create a delay effect. Our source is <code class='code prettyprint lang-sc'>Ndef(\fnoise)</code><div class='note'><span class='notelabel'>NOTE:</span> Notice that we have added the <code class='code prettyprint lang-sc'>.ar</code> message to <code class='code prettyprint lang-sc'>Ndef(\fnoise)</code>. We're also specifying that this <code class='code prettyprint lang-sc'>Ndef</code> is only 1 channel (mono) with the second argument of <code class='code prettyprint lang-sc'>.ar</code>.</div>
<p><pre class='code prettyprint lang-sc'>(
Ndef(\delay, {var source, delay;
    source = Ndef.ar(\fnoise,1); //Ndef.ar arguments: key, numChannels
    delay= CombC.ar(source,0.25,0.25,2.0);
});
)</pre>

<p>Let's add <code class='code prettyprint lang-sc'>Ndef(\delay)</code> to the master Ndef.<div class='note'><span class='notelabel'>NOTE:</span> Noitice multichannel expansion through <code class='code prettyprint lang-sc'>!2</code></div>
<p><pre class='code prettyprint lang-sc'>Ndef(\master, {Ndef.ar(\delay,1)!2});</pre>

<p>With <code class='code prettyprint lang-sc'>ServerMeter</code>, we can monitor our outputs.<pre class='code prettyprint lang-sc'>ServerMeter.new(s)</pre>

<p>Change fade time of <code class='code prettyprint lang-sc'>Ndef(\delay)</code> to 1.<pre class='code prettyprint lang-sc'>Ndef(\delay).fadeTime = 1;</pre>

<p>We're now changing the delay effect by adding an envelope triggered by an impulse. We're also modifying the delay times.<pre class='code prettyprint lang-sc'>(
Ndef(\delay, {var source, delay;
    source = Ndef.ar(\fnoise,1);
    source = source*EnvGen.kr(Env.perc(0.01,0.2), Impulse.kr(2));
    delay= CombC.ar(source,0.4,0.4,3.0);
});
)</pre>

<p>A new <code class='code prettyprint lang-sc'>Ndef</code> with a distortion effect<div class='note'><span class='notelabel'>NOTE:</span> We're adding <code class='code prettyprint lang-sc'>.ar</code> to <code class='code prettyprint lang-sc'>Ndef(\delay)</code> because we are getting the audio from that channel</div>
<p><pre class='code prettyprint lang-sc'>(
Ndef(\dist, {arg override=3, amp=1;
        (Ndef.ar(\delay,1) * override).distort * 1/override * amp;
});
)</pre>

<p>Now we're adding the distortion to the master <code class='code prettyprint lang-sc'>Ndef</code>:<pre class='code prettyprint lang-sc'>Ndef(\master, {Ndef.ar(\dist,1)!2});</pre>

<p>Let's change the values for the <code class='code prettyprint lang-sc'>\override</code> and <code class='code prettyprint lang-sc'>\amp</code> arguments:<pre class='code prettyprint lang-sc'>Ndef(\dist).set(\override, 10, \amp, 2);</pre>

<p>This control <code class='code prettyprint lang-sc'>Ndef</code> is an LFO to modulate the distortion:<pre class='code prettyprint lang-sc'>Ndef(\lfo, {SinOsc.kr(0.1).linlin(-1,1,3,6)});</pre>

<p>Map <code class='code prettyprint lang-sc'>\override</code> argument to <code class='code prettyprint lang-sc'>Ndef(\lfo)</code>:<pre class='code prettyprint lang-sc'>Ndef(\dist).map(\override, Ndef(\lfo))</pre>

<p>Another lfo, this time to modulate the frequency of <code class='code prettyprint lang-sc'>Ndef(\fnoise)</code><pre class='code prettyprint lang-sc'>Ndef(\lfo2, {LFNoise1.kr(10).linlin(-1,1,300,500)});</pre>

<p>Map frequency values to <code class='code prettyprint lang-sc'>Ndef(\lfo2)</code><pre class='code prettyprint lang-sc'>Ndef(\fnoise).map(\freq, Ndef(\lfo2));</pre>
<h3><a class='anchor' name='Pdef%20and%20Pdefn%20review'>Pdef and Pdefn review</a></h3>

<p>Before we continue with Ndefs, lets review Pdefs one more time, just to make sure we understand what they do. We're also introducing <code class='code prettyprint lang-sc'>Pdefn</code>, a similar class to <code class='code prettyprint lang-sc'>Pdef</code> but allows you to store <strong>value patterns</strong> (<code class='code prettyprint lang-sc'>Pdef</code> is used for <strong>event patterns</strong>).<pre class='code prettyprint lang-sc'>Pdef(\x, Pbind(\note, Pbrown(0, 6, 0.1, inf)));</pre>

<p><strong>Quantising</strong>
<p>When quantising to a larger number of beats, the changes become very slow if one has to wait for the next beat. Providing an outset quant value is a way to make the change so that it appears as if it had been done at the previous grid point already. The stream is fast forwarded to the current position relative to the quant grid. Providing a number larger than zero, the next possible quant point is used as outset.
<p>For example, if quant is 32, and one has just missed the first beat when changing the pattern, one has to wait for 32 beats until the change happens. Using an outset of 1, it is assumed that you had already changed the pattern at the first beat, the stream is fast forwarded to the time it would be at now if you had done so. The new pattern is inserted at the next beat (outset=1).<pre class='code prettyprint lang-sc'>Pdef(\x).quant_([8, 0, 0, 1]); //[quant, phase, timingOffset, outset]</pre>

<p><strong>Play with Pdef</strong>
<p>Now let's start the <code class='code prettyprint lang-sc'>Pdef</code> and put a Pbind.<pre class='code prettyprint lang-sc'>Pdef(\x).play;

TempoClock.default.tempo = 2.0; //a way to change global tempo

TempoClock.default.tempo = 1.0;

Pdef(\x, Pbind(\note, Pseq(Scale.major.degrees, inf)));

Pdef(\x, Pbind(\note, Pseq(Scale.minor.degrees, inf)));</pre>

<p>Now change the definition<pre class='code prettyprint lang-sc'>Pdef(\x, Pbind(\note, Pseq([0, 3, 5, 7, 9, 11], inf)));

Pdef(\x, Pbind(\freq, Pseq([1000, 1923, 245.2, 1718] / 1.2 + 0.1, inf)));</pre>

<p>Remember <code class='code prettyprint lang-sc'>Pbindf</code>?<pre class='code prettyprint lang-sc'>Pbindf(Pdef(\x), \dur, 0.1, \ctranspose, 15).play;
Pbindf(Pdef(\x), \dur, 0.3, \ctranspose, 2).play;

Pdef(\x, Pbind(\note, Pseq([0, 3, 5, 7, 9, 11], inf)));</pre>

<p><code class='code prettyprint lang-sc'>Pdefn(key pat)</code>
<p>Similar to Pdefn. Allows for a value pattern to be changed on the fly!<pre class='code prettyprint lang-sc'>Pdefn(\x, Pbrown(0, 6, 0.1, inf));
Pbind(\note, Pdefn(\x), \dur, 0.3).play;
Pbind(\note, Pdefn(\x), \dur, 0.1, \ctranspose, 15).play;
// now change the definition
Pdefn(\x, Pseq([0, 3, 5, 7, 9, 11], inf));
Pdefn(\x, Pseq([0, 3, 3, 7], inf) + Pseq([0, [0, 3], [0, 5, 7]], inf));</pre>
<h3><a class='anchor' name='Combining%20Ndefs%20and%20Pdefs'>Combining Ndefs and Pdefs</a></h3>

<p>Now: let's combine Ndefs and Pdefs!
<p>First, play the <code class='code prettyprint lang-sc'>Ndef</code> to start 'player'.
<p>By default when you start an <code class='code prettyprint lang-sc'>Ndef</code> it is assigned a stereo output
<p>Now we can start putting things into it<pre class='code prettyprint lang-sc'>Ndef(\sound).play;</pre>

<p>Let's give this <code class='code prettyprint lang-sc'>Ndef</code> a <code class='code prettyprint lang-sc'>fadeTime</code> of 1 second:<pre class='code prettyprint lang-sc'>Ndef(\sound).fadeTime = 1;</pre>

<p>We're adding the <code class='code prettyprint lang-sc'>Ndef(\a)</code>, which is empty and modulating the amplitude with the mouse<pre class='code prettyprint lang-sc'>Ndef(\sound, {Ndef(\a).ar*MouseX.kr(0,1)});</pre>

<p>Now let's put <code class='code prettyprint lang-sc'>Pdef(\a)</code> into <code class='code prettyprint lang-sc'>Ndef(\a)</code><pre class='code prettyprint lang-sc'>Ndef(\a, Pdef(\a));</pre>

<p>Specify the pattern, we're putting <code class='code prettyprint lang-sc'>Pdefn(\a)</code> to change midinotes<pre class='code prettyprint lang-sc'>Pdef(\a, Pbind(\midinote, Pdefn(\x)));</pre>

<p>Now we're specifying what <code class='code prettyprint lang-sc'>Pdefn(\x)</code> is (a sequence of three midinotes)<pre class='code prettyprint lang-sc'>Pdefn(\x, Pseq([60,61,62], inf));</pre>

<p>Now nothing in <code class='code prettyprint lang-sc'>Ndef(\sound)</code><pre class='code prettyprint lang-sc'>Ndef(\sound, 0);</pre>

<p>Let's put something back again<pre class='code prettyprint lang-sc'>Ndef(\sound, {Ndef(\a).ar*MouseX.kr(0,1)});</pre>

<p>Quantise <code class='code prettyprint lang-sc'>Pdef(\a)</code><pre class='code prettyprint lang-sc'>Pdef(\a).quant_([8, 0, 0, 1]); //quantaise:  [quant, phase, timingOffset, outset]</pre>

<p>Change midi note sequence<pre class='code prettyprint lang-sc'>Pdefn(\x, Pseq([60,61,69], inf));</pre>

<p>Now set duration to 0.2<pre class='code prettyprint lang-sc'>Pdef(\a, Pbind(\midinote, Pdefn(\x), \dur, 0.2));</pre>

<p>Now new pattern of floats<pre class='code prettyprint lang-sc'>Pdefn(\y, Pseq([0.1,0.2,0.3], inf));</pre>

<p>Map previous pattern of floats to duration<pre class='code prettyprint lang-sc'>Pdef(\a, Pbind(\midinote, Pdefn(\x), \dur, Pdefn(\y)));</pre>

<p>Change duration pattern<pre class='code prettyprint lang-sc'>Pdefn(\y, Pseq([0.1,0.2,0.3,0.1,0.1,0.1], inf));</pre>

<p>Ring modulate <code class='code prettyprint lang-sc'>Ndef(\a)</code> containing <code class='code prettyprint lang-sc'>Pdef(\a)</code><pre class='code prettyprint lang-sc'>Ndef(\sound, {Ndef(\a).ar*SinOsc.ar(400);});</pre>

<p>Change pitch set:<pre class='code prettyprint lang-sc'>Pdefn(\x, Pseq([ 60,62,63,65,67,69,70,72], inf));</pre>

<p>Take <code class='code prettyprint lang-sc'>Ndef(\a)</code> and <code class='code prettyprint lang-sc'>Mix</code> it to 1 channel, then pan it modulating it with a <code class='code prettyprint lang-sc'>SinOsc</code><pre class='code prettyprint lang-sc'>Ndef(\sound, {Pan2.ar(Mix(Ndef(\a).ar), SinOsc.kr(0.1).linlin(-1,1,0,1));});</pre>

<p>Change the content of <code class='code prettyprint lang-sc'>Ndef(\a)</code><pre class='code prettyprint lang-sc'>Ndef(\a, {arg freq=220, amp=0.1; SinOsc.ar(freq,0,amp)!2});</pre>

<p>New <code class='code prettyprint lang-sc'>Ndef(\mouse)</code> to modulate frequency<pre class='code prettyprint lang-sc'>Ndef(\mouse, {MouseY.kr(160,872)});</pre>

<p>Map freq argument to <code class='code prettyprint lang-sc'>Ndef(\mouse)</code><pre class='code prettyprint lang-sc'>Ndef(\a).map(\freq, Ndef(\mouse));</pre>

<p>Unmap frequency<pre class='code prettyprint lang-sc'>Ndef(\a).unmap(\freq);</pre>

<p>Play <code class='code prettyprint lang-sc'>Pdef(\a)</code> pattern on <code class='code prettyprint lang-sc'>Ndef(\a)</code><pre class='code prettyprint lang-sc'>Ndef(\a, Pdef(\a));</pre>

<p><code class='code prettyprint lang-sc'>Prand</code> major scale<pre class='code prettyprint lang-sc'>Pdefn(\x, Prand([60,62,64,65,67,69,71,72], inf));</pre>

<p>New <code class='code prettyprint lang-sc'>Pdef(\b)</code> with chromatic scale with <code class='code prettyprint lang-sc'>Pdefn(\y)</code> controlling duration<pre class='code prettyprint lang-sc'>Pdef(\b, Pbind(\midinote, Pseq((60..72), inf), \dur, Pdefn(\y)));</pre>

<p>Ppar to play both <code class='code prettyprint lang-sc'>Pdef(\a)</code> and new <code class='code prettyprint lang-sc'>Pdef(\b)</code> at the same time<pre class='code prettyprint lang-sc'>Ndef(\a, Ppar([Pdef(\a), Pdef(\b)]));</pre>

<p>New <code class='code prettyprint lang-sc'>Ndef(\b)</code> for ring modulation<pre class='code prettyprint lang-sc'>Ndef(\b, {SinOsc.ar(1000,0,1)});</pre>

<p>Ringmodulate patterns<pre class='code prettyprint lang-sc'>Ndef(\sound, {Ndef(\a).ar*Ndef(\b).ar});</pre>

<p>Change duration of <code class='code prettyprint lang-sc'>Pdef(\b)</code> with <code class='code prettyprint lang-sc'>Pdefn(\y)</code><pre class='code prettyprint lang-sc'>Pdefn(\y, Pseq(Array.fill(16,{[0.1,0.2,0.4].choose}).postln, inf));</pre>

<p>Drop <code class='code prettyprint lang-sc'>Pdef(\a)</code><pre class='code prettyprint lang-sc'>Ndef(\a, Pdef(\b));</pre>

<p>Drop contents of <code class='code prettyprint lang-sc'>Ndef(\sound)</code><pre class='code prettyprint lang-sc'>Ndef(\sound, 0)</pre>
<h3><a class='anchor' name='Effects%20and%20mixing%20with%20Ndefs'>Effects and mixing with Ndefs</a></h3>

<p>Ndefs provide a versatile and powerful way of using effects and mixing audio. You can filter and mix signals and change these configurations on the fly! As an analogy: imagine being able to recable/repatch you gear on the fly at the same time having the ability to modify your gear (effects, synths, etc.), all of this while you are playing the sounds! You can do this with Ndefs and this is powerful stuff (and of course it can be very useful for performance!).
<p><strong>Filtering</strong>:<pre class='code prettyprint lang-sc'>Ndef(\filter, {Ndef(\sine).ar * PinkNoise.ar(3)})

(
Ndef(\filter2, {Ndef(\filter).ar * SinOsc.ar(300)});
Ndef(\filter3, {Ndef(\filter2).ar * SinOsc.ar(1).linlin(-1,1,0,2)});
Ndef(\filter4, {LPF.ar(Ndef(\filter3).ar, MouseX.kr(400,8000));});
Ndef(\master, {Ndef(\filter4)});
)</pre>

<p><strong>Mixing with Ndefs</strong>
<p>A 6 channel stereo mixer:<pre class='code prettyprint lang-sc'>Ndef(\master).ar(numChannels: 2)
Ndef(\master).play;

Ndef(\chan1, {arg pos=0; Pan2.ar(Mix(Ndef(\in1).ar), pos)});
Ndef(\chan2, {arg pos=0; Pan2.ar(Mix(Ndef(\in2).ar), pos)});
Ndef(\chan3, {arg pos=0; Pan2.ar(Mix(Ndef(\in3).ar), pos)});
Ndef(\chan4, {arg pos=0; Pan2.ar(Mix(Ndef(\in4).ar), pos)});
Ndef(\chan5, {arg pos=0; Pan2.ar(Mix(Ndef(\in5).ar), pos)});
Ndef(\chan6, {arg pos=0; Pan2.ar(Mix(Ndef(\in6).ar), pos)});

Ndef(\master, {
    Ndef(\chan1).ar +  Ndef(\chan2).ar +
    Ndef(\chan3).ar +  Ndef(\chan4).ar +
    Ndef(\chan5).ar +  Ndef(\chan6).ar;
});

//put stuff in the mixer:
Ndef(\in1, {SinOsc.ar(60.midicps,0,0.1)});
Ndef(\in2, {SinOsc.ar(63.midicps,0,0.1)});
Ndef(\in3, {SinOsc.ar(66.midicps,0,0.1)});
Ndef(\in4, {SinOsc.ar(69.midicps,0,0.1)});
Ndef(\in5, {SinOsc.ar(72.midicps,0,0.1)});
Ndef(\in6, {SinOsc.ar(75.midicps,0,0.1)});

ServerMeter.new(s)</pre>

<p>Now a more economic way of writing the same as above with a smart use of collections:<pre class='code prettyprint lang-sc'>(
//set your basic mixer
Ndef(\master).play;
~numChans = 6; //select how many channels you want in your mixer
~fadeTime = 1; //set fadeTime
//create array of channel Ndefs
~chans = [];
(1..~numChans).do{|item| ~chans = ~chans.add(Ndef((\chan++item).asSymbol)); };
//create array of input Ndefs
~ins = [];
(1..~numChans).do{|item| ~ins = ~ins.add(Ndef((\in++item).asSymbol)); };
//create individual channel strip
~chans.do{|item, index| var channel, input;
    item.source = {arg pos=0, vol=0; Pan2.ar(Mix(~ins[index].ar), pos) * vol.dbamp.round(0.0001) };
};
~chanMix = [];
~chans.do{|item| ~chanMix = ~chanMix.add(item); };
Ndef(\master, {~chanMix.sum;});
~chans.do{|item| item.fadeTime = ~fadeTime}; //set fadeTime for channels
~ins.do{|item| item.fadeTime = ~fadeTime}; //set fadeTime for ins
Ndef(\master).fadeTime = ~fadeTime; //set fadeTime for master
Ndef(\master)[100] = \filter -&gt; {arg in, vol; in * vol.dbamp.round(0.0001)}; //master vol at index of 100
)

~chans; //array of channel Ndefs
~ins; //array of input Ndefs

(
Array.series(~numChans, 48, 3).do{|item, index|
    ~ins[index].source = {SinOsc.ar(item.midicps,0,0.2/~numChans)};
};
)

~chans.do{|item| item.lag(\pos, 5)}; //change lag for pos arg

(
~chans.do{|item, index|
    item.set(\pos, rrand(-1,1.0));
};
)

(
~chans.do{|item, index|
    item.set(\pos, index.linlin(0,~numChans-1,-1,1));
};
)

~buf = Buffer.read(s, "/Users/federicoreuben/Music/MastersExamples/2 Nicotine &amp; Gravy.aiff");

(
~playFunc = {arg bufnum=0, start=0, amp=1;
    PlayBuf.ar(2, bufnum, BufRateScale.kr(bufnum), startPos: BufFrames.kr(bufnum)*start, loop: 1)*amp;
};
)

~ins.do{|item, index| item.source = {~playFunc.value(~buf, index.linlin(0,5,0,1), 1/~numChans) } };

~ins.do{|item| item.source =  {Impulse.ar(rrand(1,5.0))/~numChans} };

~ins[0].source = {~playFunc.value(~buf.bufnum, 0, 0.2) };
~ins[1].source = {~playFunc.value(~buf.bufnum, 0.5, 0.2) };
~ins[2].source =  Pdef(\pat, Pbind(\midinote, Prand((40,42..100), inf), \dur, 0.2));


~chans.do{|item| item.xset(\vol, [-90, 0, -20, -40].choose)}; //evaluate several times
~chans.do{|item| item.xset(\vol, -90)}; //all vols down
~chans.do{|item| item.xset(\vol, 0)}; //all vols up

//master fader
Ndef(\master).xset(\vol, -90);
Ndef(\master).xset(\vol, -10);

//inserts in master
Ndef(\master)[1] = \filter -&gt; {|in| LPF.ar(in, MouseX.kr(20,20000, 1))};
Ndef(\master)[2] = \filter -&gt; {|in| HPF.ar(in, MouseY.kr(20,20000, 1))};
//remove inserts
Ndef(\master).removeAt(1,~fadeTime);
Ndef(\master).removeAt(2,~fadeTime);

~ins.do{|item| item.source = 0};

Ndef.all //all active Ndefs
Ndef.clear; //get rid of all Ndefs</pre>

<p>Now you get an idea of the power of Ndefs, now, start having fun!!
<p><strong>Excercises</strong><ol>
<li>Write a simple <code class='code prettyprint lang-sc'>SynthDef</code> and add it to the <code class='code prettyprint lang-sc'>Server</code>.<li>Create a <code class='code prettyprint lang-sc'>Pdef</code> containing a <code class='code prettyprint lang-sc'>Pbind</code> and use your <code class='code prettyprint lang-sc'>SynthDef</code> as <code class='code prettyprint lang-sc'>\instrument</code>.<li>Use <code class='code prettyprint lang-sc'>Ndef</code> to play your <code class='code prettyprint lang-sc'>Pdef</code> and to filter it through another <code class='code prettyprint lang-sc'>Ndef</code> - try applying a simple filter, like a delay line (<code class='code prettyprint lang-sc'>DelayL</code>) or a <code class='code prettyprint lang-sc'>LPF</code>.</ol>
<div class='note'><span class='notelabel'>NOTE:</span> Various examples, ideas, etc. have been taken or derived from the SC documentation, Paul Berg, David Cottle, Nick Collins, and probably lots of other people in the SuperCollider community.</div><div class='doclink'>helpfile source: <a href='file:///Users/federicoreuben/Library/Application Support/SuperCollider/Extensions/ComputerPlay/HelpSource/Workshops/Patterns and Ndefs.schelp'>/Users/federicoreuben/Library/Application Support/SuperCollider/Extensions/ComputerPlay/HelpSource/Workshops/Patterns and Ndefs.schelp</a><br>link::Workshops/Patterns and Ndefs::<br>sc version: 3.8.0</div></div></body></html>